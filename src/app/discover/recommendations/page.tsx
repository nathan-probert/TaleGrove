'use client';

import React, { useEffect, useState } from 'react';
import {
  getUserId,
  getUserFolders,
  addBook,
  addBookToFolders,
  saveRecommendation,
  getRecommendations,
} from '@/lib/supabase';
import { getOpenLibraryRecommendation } from '@/lib/books_api';
import { BookRecommendation, OpenLibraryRecommendationInfo, Book, Folder, BookStatus, RecommendationStatus } from '@/types';
import { Loader2 } from 'lucide-react';
import { AddBookModal } from '@/components/Modals/AddBookModal';
import router from 'next/router';

export default function RecommendationsPage() {
  const [isLoading, setIsLoading] = useState(true);
  const [recommendations, setRecommendations] = useState<BookRecommendation[]>([]);
  const [detailedRecs, setDetailedRecs] = useState<{ [index: number]: OpenLibraryRecommendationInfo }>({});
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isFetchingBook, setIsFetchingBook] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // State for AddBookModal
  const [userId, setUserId] = useState<string | null>(null);
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [folders, setFolders] = useState<Folder[]>([]);
  const [selectedFolderIds, setSelectedFolderIds] = useState<string[]>([]);
  const [selectedStatus, setSelectedStatus] = useState<BookStatus>(BookStatus.wishlist);
  const [rating, setRating] = useState<number | null>(null);
  const [notes, setNotes] = useState<string>('');
  const [dateRead, setDateRead] = useState<string>('');
  const [isAdding, setIsAdding] = useState(false);
  const [currentBookForModal, setCurrentBookForModal] = useState<Book | null>(null);

  // Fetch user ID
  useEffect(() => {
    const fetchAndSetUserId = async () => {
      const id = await getUserId();
      setUserId(id);
    };
    fetchAndSetUserId();
  }, []);

  // Fetch user folders
  useEffect(() => {
    const loadFolders = async () => {
      if (!userId) return;
      try {
        const folderData = await getUserFolders(userId);
        setFolders([...folderData]);
      } catch (error) {
        console.error("Failed to fetch folders:", error);
        setError('Failed to load user folders.');
      }
    };
    if (userId) loadFolders();
  }, [userId]);

  // Fetch the list of recommendations (titles + authors)
  useEffect(() => {
    const loadBasicRecs = async () => {
      if (!userId) return; // Ensure userId is set
      setIsLoading(true);
      try {
        const recs = await getRecommendations(userId);
        setRecommendations(recs || []);
      } catch (err: any) {
        setError(err.message || 'Failed to load recommendations.');
      } finally {
        setIsLoading(false);
      }
    };

    // Only call loadBasicRecs when both userId are available
    if (userId) {
      loadBasicRecs();
    }
  }, [userId]);


  // Fetch OpenLibrary detail for the current index (only when needed)
  useEffect(() => {
    const fetchCurrentBook = async () => {
      if (!recommendations[currentIndex] || detailedRecs[currentIndex]) return;

      setIsFetchingBook(true);
      try {
        const rec = recommendations[currentIndex];
        const detailed = await getOpenLibraryRecommendation(rec.title, rec.author, 1);
        setDetailedRecs((prev) => ({ ...prev, [currentIndex]: detailed }));
      } catch (err: any) {
        console.error(`Error loading book at index ${currentIndex}:`, err);
        setError(err.message || 'Failed to load book details.');
      } finally {
        setIsFetchingBook(false);
      }
    };

    fetchCurrentBook();
  }, [currentIndex, recommendations, detailedRecs]);

  const handleNext = () => {
    if (currentIndex < recommendations.length - 1) {
      setCurrentIndex(currentIndex + 1);
      // Reset modal related states for the next book
      setSelectedFolderIds([]);
      setSelectedStatus(BookStatus.wishlist);
      setRating(null);
      setNotes('');
      setDateRead('');
      setCurrentBookForModal(null);
    } else {
      // All recommendations have been reviewed
      setCurrentIndex(recommendations.length);
    }
  };

  const handleAdd = () => {
    const currentDetailedRec = detailedRecs[currentIndex];
    if (!currentDetailedRec || !userId) {
      setError("Cannot add book without details or user session.");
      return;
    }

    const bookIsbn = currentDetailedRec.isbn

    // Prepare book data for the modal
    // Ensure this matches the Book type, excluding fields auto-generated by DB (like id, created_at, updated_at initially)
    const bookDataForModal: Omit<Book, 'id' | 'created_at' | 'updated_at'> & { id?: string } = {
      title: currentDetailedRec.title,
      author: currentDetailedRec.authors,
      user_id: userId,
      status: BookStatus.wishlist, // Default for modal
      rating: null,
      notes: null,
      date_read: null,
      book_id: currentDetailedRec.id, // OpenLibrary ID
      isbn: bookIsbn ?? "",
      categories: currentDetailedRec.categories,
      cover_url: currentDetailedRec.coverUrl,
    };
    setCurrentBookForModal(bookDataForModal as Book); // Cast for state, actual DB insert handles missing fields

    setSelectedStatus(BookStatus.wishlist); // Reset status for modal
    setRating(null);
    setNotes('');
    setDateRead('');
    setIsAddModalOpen(true);
  };

  const handleReject = async () => {
    if (!userId) {
      setError("User session not found. Cannot save rejection.");
      return;
    }
    const rec = recommendations[currentIndex];
    if (rec) {
      try {
        await saveRecommendation(userId, { title: rec.title, author: rec.author }, RecommendationStatus.Rejected);
      } catch (err: any) {
        console.error("Error saving rejection:", err);
        // Optionally set an error state to inform the user
        setError(err.message || "Failed to save rejection.");
      }
    }
    handleNext();
  };

  const handleAccept = async () => {
    if (!userId) {
      setError("User session not found. Cannot save acceptance.");
      return;
    }
    const rec = recommendations[currentIndex];
    if (rec) {
      try {
        await saveRecommendation(userId, { title: rec.title, author: rec.author }, RecommendationStatus.Accepted);
      } catch (err: any) {
        console.error("Error saving acceptance:", err);
        // Optionally set an error state to inform the user
        setError(err.message || "Failed to save acceptance.");
      }
    }
    handleNext();
  }

  const handleFolderSelectionChange = (folderId: string, isSelected: boolean) => {
    setSelectedFolderIds(prev =>
      isSelected ? [...prev, folderId] : prev.filter(id => id !== folderId)
    );
  };

  const handleStatusChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newStatus = event.target.value as BookStatus;
    setSelectedStatus(newStatus);
    if (newStatus !== BookStatus.completed) {
      setRating(null);
      setNotes('');
      setDateRead('');
    }
  };

  const addBookToSupabaseAndFolders = async (
    book: Book, // Expects a Book-like object, id might be missing if new
    folderIds: string[],
    status: BookStatus,
    currentRating: number | null,
    currentNotes: string | null,
    currentDateRead: string | null
  ) => {
    if (!userId) throw new Error("User ID not found");

    const bookIsbn = book.isbn

    // Prepare the object for Supabase, ensuring it matches the expected structure for `addBook`
    const bookDataForSupabase: Partial<Book> & { user_id: string; title: string; author: string; status: BookStatus; book_id?: string; isbn?: string; categories?: string[]; cover_url?: string; } = {
      user_id: userId,
      title: book.title,
      author: book.author,
      status: status,
      book_id: book.book_id,
      isbn: bookIsbn ?? "",
      categories: book.categories,
      cover_url: book.cover_url,
    };

    if (status === BookStatus.completed) {
      bookDataForSupabase.rating = currentRating;
      bookDataForSupabase.notes = currentNotes;
      bookDataForSupabase.date_read = currentDateRead;
    } else {
      bookDataForSupabase.rating = null;
      bookDataForSupabase.notes = null;
      bookDataForSupabase.date_read = null;
    }
    
    const addedBook = await addBook(bookDataForSupabase as Book); // Cast to Book for the addBook function call
    if (addedBook && addedBook.id && folderIds.length > 0) { // Ensure addedBook and addedBook.id exist
      await addBookToFolders(addedBook.id, folderIds, userId);
    }
    return addedBook;
  };

  const handleConfirmAddBookFromModal = async () => {
    if (!currentBookForModal || !userId) {
      alert("Book data or user session is missing.");
      return;
    }
    setIsAdding(true);
    if (selectedStatus === BookStatus.completed && rating !== null && (rating < 1 || rating > 10)) {
      alert("Rating must be between 1 and 10 for completed books.");
      setIsAdding(false);
      return;
    }

    try {
      await addBookToSupabaseAndFolders(
        currentBookForModal,
        selectedFolderIds,
        selectedStatus,
        rating,
        notes,
        dateRead
      );
      setIsAddModalOpen(false);
    } catch (error: any) {
      console.error("Error adding book from group recommendation:", error);
      alert(`Failed to add book: ${error.message || 'Unknown error'}`);
    } finally {
      setIsAdding(false);
      handleAccept();
    }
  };

  const statusOptions = [
    { value: BookStatus.wishlist, label: 'Wishlist' },
    { value: BookStatus.reading, label: 'Reading' },
    { value: BookStatus.completed, label: 'Completed' },
  ];

  const currentDetailedRec = detailedRecs[currentIndex];

  return (
    <div className="px-6 py-8 max-w-3xl mx-auto">
      <button
        onClick={() => router.back()}
        className="mb-6 text-link hover:opacity-80 transition duration-150 flex items-center"
      >
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
        </svg>
        Back to Group
      </button>

      <h1 className="text-4xl font-bold text-center mb-8">Group Recommendations</h1>

      {isLoading ? (
        <div className="flex justify-center mt-10">
          <Loader2 className="h-8 w-8 animate-spin text-gray-500" />
        </div>
      ) : error ? (
        <div className="p-4 bg-red-100 text-red-700 rounded-md mb-6">
          Error: {error}
        </div>
      ) : recommendations.length === 0 ? (
        <div className="text-center text-gray-500 italic">
          No recommendations available for this group yet.
        </div>
      ) : currentIndex >= recommendations.length ? (
        <div className="text-center text-gray-600 font-medium mt-20">
          You've reviewed all the recommendations!
        </div>
      ) : isFetchingBook || !currentDetailedRec ? (
        <div className="flex justify-center mt-10">
          <Loader2 className="h-8 w-8 animate-spin text-gray-500" />
          <p className="ml-4 text-gray-600">Loading book details...</p>
        </div>
      ) : (
        <div className="bg-white rounded-2xl shadow-lg p-6 border border-gray-100">
          <div className="flex flex-col lg:flex-row gap-6 lg:items-center">
            <div className="lg:w-1/3">
              <div className="aspect-[2/3] w-full border border-black rounded-lg shadow-md overflow-hidden">
                <img
                  src={currentDetailedRec.coverUrl || '/placeholder.jpg'}
                  alt={currentDetailedRec.title}
                  className="w-full h-full object-cover"
                />
              </div>
            </div>
            <div className="lg:w-2/3 space-y-4">
              <h2 className="text-2xl font-semibold text-black">{currentDetailedRec.title}</h2>
              <p className="text-gray-600 italic">by {currentDetailedRec.authors}</p>
              {currentDetailedRec.description && (
                <div className="text-gray-700 max-h-72 overflow-y-auto border-l-4 border-gray-200 pl-4">
                  <div dangerouslySetInnerHTML={{ __html: currentDetailedRec.description }} />
                </div>
              )}
            </div>
          </div>

          <div className="flex justify-center mt-8 gap-4">
            <button
              onClick={handleAdd}
              className="bg-green-100 hover:bg-green-200 text-green-700 px-4 py-2 rounded-xl font-medium"
            >
              Add To Library
            </button>
            <button
              onClick={handleReject}
              className="bg-red-100 hover:bg-red-200 text-red-700 px-4 py-2 rounded-xl font-medium"
            >
              Reject
            </button>
          </div>
        </div>
      )}

      {isAddModalOpen && currentBookForModal && userId && (
        <AddBookModal
          book={currentBookForModal}
          isOpen={isAddModalOpen}
          onClose={() => setIsAddModalOpen(false)}
          onConfirm={handleConfirmAddBookFromModal}
          folders={folders}
          selectedFolderIds={selectedFolderIds}
          selectedStatus={selectedStatus}
          rating={rating ?? undefined} // Pass undefined if null
          setRating={setRating}
          notes={notes}
          setNotes={setNotes}
          dateRead={dateRead}
          setDateRead={setDateRead}
          handleFolderSelectionChange={handleFolderSelectionChange}
          handleStatusChange={handleStatusChange}
          statusOptions={statusOptions}
          isAdding={isAdding}
        />
      )}
    </div>
  );
}
